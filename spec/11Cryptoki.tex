\chapter{Программный интерфейс}\label{CRYPTOKI}

\section{Общие положения}

PKCS\#11, принятый как СТБ 34.101.21, определяет программный
интерфейс взаимодействия с КТ, называемый Cryptoki.
Интерфейс содержит фиксированный набор функций, позволяющий
выполнять широкий набор криптографических команд.

Cryptoki оперирует такими понятиями, как механизм и ключевой объект.
%
В настоящем разделе уточняется использование введенных
в СТБ 34.101.21 объектов и вводятся новые механизмы для поддержки
алгоритмов СТБ 34.101.45 (генерация ключей, ЭЦП, транспорт ключа).

\section{Объекты}

\subsection{Атрибуты}

Объектам Cryptoki назначаются атрибуты: класс, тип, описание и др. 
%
Атрибуты указываются в шаблоне объекта.
%
В зависимости от контекста атрибуты подчиняются тем или иным правилам.
Правила, задействованные в настоящем стандарте, собраны в
таблице~\ref{Table.CRYPTOKI.AttrUse}. Далее при описании атрибута будут
указываться номера правил из таблицы.

\begin{table}[H]
\caption{Правила использования атрибутов}\label{Table.CRYPTOKI.AttrUse}
\begin{tabular}{|c|p{420pt}|}
\hline
Номер & Правило\\
\hline
\hline
1 & ДОЛЖЕН быть указан при создании объекта с помощью
\verb|C_CreateObject|\\
\hline
%
% 2 & НЕ ДОЛЖЕН быть указан при создании объекта с помощью
%\verb|C_CreateObject|\\
%\hline
%
3 & ДОЛЖЕН быть указан при генерации объекта с помощью
\verb|C_GenerateKey| или \verb|C_GenerateKeyPair|\\
\hline
4 & НЕ ДОЛЖЕН быть указан при генерации объекта с помощью
\verb|C_GenerateKey| или \verb|C_GenerateKeyPair|\\
\hline
5 & ДОЛЖЕН быть указан при извлечении объекта с помощью
\verb|C_UnwrapKey|\\
\hline
6 & НЕ ДОЛЖЕН быть указан при извлечении объекта с помощью
\verb|C_UnwrapKey|\\
\hline
7 & НЕ МОЖЕТ быть раскрыт, если объект имеет атрибут
\verb|CKA_SENSITIVE| со значением \verb|CK_TRUE| или атрибут
\verb|CKA_EXTRACTABLE| со значением \verb|CK_FALSE|\\
\hline
\end{tabular}
\end{table}

\subsection{Параметры эллиптической кривой}

Криптографический механизм описывается структурой~\verb|CK_MECHANISM_INFO|.
описания механизма должны быть установлены следующие информационные флаги:

Если в криптографическом механизме используются параметры ЭК 
(см.~\ref{CRYPTO.Params}), то в структуре должны быть установлены 
следующие флаги: 
\begin{itemize}
\item[--]
\verb|CKF_EC_F_P|~-- используется ЭК над простым полем;
\item[--]
\verb|CKF_EC_NAMEDCURVE|~-- параметры ЭК задаются идентификатором;
\item[--]
\verb|CKF_EC_UNCOMPRESS|~-- точки ЭК задаются в несжатом виде.
\end{itemize}

Параметры ЭК должны кодироваться по правилам DER и указываться 
как значение атрибута \verb|CKA_EC_PARAMS|.

Параметры ЭК однозначно определяют длины личного и открытого ключей, 
подписываемого хэш-значения и подписи: $l/4$, $l/2$, $l/4$ и $3l/8$ 
октетов соответственно, где~$l$~-- уровень стойкости. 

\subsection{Объект открытого ключа}

%2.3.3

Объект открытого ключа СТБ 34.101.45 должен принадлежать
классу \verb|CKO_PUBLIC_KEY| и иметь тип ключа \verb|CKK_EC|.
%
В таблице~\ref{Table.CRYPTOKI.EcPubkeyAttrs} указаны
атрибуты объекта, дополнительные к обычным атрибутам 
класса~\verb|CKO_PUBLIC_KEY|. 

\begin{table}[H]
\caption{Атрибуты объекта открытого ключа}\label{Table.CRYPTOKI.EcPubkeyAttrs}
\begin{tabular}{|c|c|c|c|}
\hline
Атрибут & Правила & Тип & Значение\\
\hline
\hline
\verb|CKA_EC_PARAMS| & 1, 3 & \texttt{Byte array} &
параметры ЭК\\
\hline
\verb|CKA_EC_POINT| & 1, 4 & \texttt{Byte array} &
значение открытого ключа, $l/2$ октетов\\
\hline
\end{tabular}
\end{table}

Ниже приведен пример шаблона для создания объекта открытого ключа СТБ 34.101.45:
\begin{verbatim}
CK_OBJECT_CLASS class = CKO_PUBLIC_KEY;
CK_KEY_TYPE keyType = CKK_EC;
CK_UTF8CHAR label[] = "BIGN public key object";
CK_BYTE bignParams[] = {...};
CK_BYTE bignPubKey[] = {...};
CK_BBOOL true = CK_TRUE;
CK_ATTRIBUTE template[] = {
  {CKA_CLASS, &class, sizeof(class)},
  {CKA_KEY_TYPE, &keyType, sizeof(keyType)},
  {CKA_TOKEN, &true, sizeof(true)},
  {CKA_LABEL, label, sizeof(label) - 1},
  {CKA_EC_PARAMS, bignParams, sizeof(bignParams)},
  {CKA_EC_POINT, bignPubKey, sizeof(bignPubKey)}
};
\end{verbatim}

\subsection{Объект личного ключа}

%2.3.4

Объект личного ключа СТБ 34.101.45 должен принадлежать
классу~\verb|CKO_PRIVATE_KEY| и иметь тип ключа~\verb|CKK_EC|.
В таблице~\ref{Table.CRYPTOKI.EcPrivkeyAttrs} указаны
атрибуты объекта личного ключа, дополнительные к обычным
атрибутам класса~\verb|CKO_PRIVATE_KEY|.

\begin{table}[H]
\caption{Атрибуты объекта личного ключа}\label{Table.CRYPTOKI.EcPrivkeyAttrs}
\begin{tabular}{|c|c|c|c|}
\hline
Атрибут & Правила & Тип & Значение\\
\hline
\hline
\verb|CKA_EC_PARAMS| & 1, 4, 6 & \texttt{Byte array} &
параметры ЭК\\
\hline
\verb|CKA_VALUE| & 1, 4, 6, 7 & \texttt{Big integer} &
личный ключ, $l/4$ октетов\\
\hline
\verb|CKA_ID| & \doubt{???} & \texttt{Byte array} & идентификатор\\
\hline
\end{tabular}
\end{table}


Атрибут \verb|CKA_ID| является необязательным. 
Его следует использовать тогда, когда на КТ хранятся 
несколько личных ключей, и требуется выбирать один из них.
При идентификации личных ключей КТ, соответствующих СТБ 34.101.79,
атрибут должен состоять из одного~байта.

\doubt{
Личный ключ генерируется только как часть пары ключей,
при генерации параметры ЭК указываются только в шаблоне
открытого ключа.
}

Ниже приведен пример шаблона для создания объекта личного ключа СТБ 34.101.45:
\begin{verbatim}
CK_OBJECT_CLASS class = CKO_PRIVATE_KEY;
CK_KEY_TYPE keyType = CKK_EC;
CK_UTF8CHAR label[] = "BIGN private key object";
CK_BYTE subject[] = {...};
CK_BYTE id[] = {123};
CK_BYTE bignParams[] = {...};
CK_BYTE bignPrivKey[] = {...};
CK_BBOOL true = CK_TRUE;
CK_ATTRIBUTE template[] = {
  {CKA_CLASS, &class, sizeof(class)},
  {CKA_KEY_TYPE, &keyType, sizeof(keyType)},
  {CKA_TOKEN, &true, sizeof(true)},
  {CKA_LABEL, label, sizeof(label) - 1},
  {CKA_SUBJECT, subject, sizeof(subject)},
  {CKA_ID, id, sizeof(id)},
  {CKA_SENSITIVE, &true, sizeof(true)},
  {CKA_DERIVE, &true, sizeof(true)},
  {CKA_EC_PARAMS, bignParams, sizeof(bignParams)},
  {CKA_VALUE, bignPrivKey, sizeof(bignPrivKey)}
};
\end{verbatim}

\section{Механизмы}

\subsection{Механизм CKM\_EC\_KEY\_PAIR\_GEN}

%2.3.5

Для генерации ключей СТБ 34.101.45 должен использоваться стандартный 
механизм \verb|CKM_EC_KEY_PAIR_GEN|. Механизм не имеет параметров. 

Механизм поддерживается функцией~\verb|C_GenerateKeyPair|. 
%
Описатель механизма и шаблоны объектов открытого и личного
ключей подаются на вход~\verb|C_GenerateKeyPair|. Параметры ЭК задаются в 
атрибуте \verb|CKA_EC_PARAMS| шаблона открытого ключа.

\subsection{Механизм CKM\_BIGN}

Для выработки ЭЦП в соответствии с СТБ 34.101.45 по заданному хэш-значению 
сообщения должен использоваться механизм \verb|CKM_BIGN|. Механизм может 
дополнительно реализовывать проверку ЭЦП. 
%
Параметр механизма~--- DER-код идентификатора используемого алгоритма 
хэширования.

Идентификатор механизма: \texttt{0x00008001}.

Механизм поддерживается функциями выработки и проверки ЭЦП: 
\verb|C_SignInit|, \verb|C_Sign|, \verb|C_VerifyInit|, \verb|C_Verify|.

При выработке подписи описатели механизма и объекта
личного ключа подаются на вход функции \verb|C_SignInit|.
Указатели на подписываемое хэш-значение и выходное значение подписи
вместе с их размерами подаются на вход функции \verb|C_Sign|.

При проверке подписи описатели механизма и объекта
открытого ключа подаются на вход функции \verb|C_VerifyInit|.
Указатели на подписанное хэш-значение и значение подписи
вместе с их размерами подаются на вход функции \verb|C_Verify|.

Длины входных и выходных данных (хэш-значение, подпись) функций
\verb|C_Sign| и \verb|C_Verify| должны соответствовать
уровню стойкости~$l$ соответствующего ключевого объекта.

\subsection{Механизм CKM\_BIGN\_HBELT}

Для выработки ЭЦП в соответствии с алгоритмами~\texttt{bign-with-hbelt} 
(см.~\ref{CRYPTO.Sign}) должен использоваться механизм \verb|CKM_BIGN_HBELT|. 
Механизм может дополнительно реализовывать проверку ЭЦП. 
%
Механизм не имеет параметров.

Идентификатор механизма: \texttt{0x00008002}.

Механизм поддерживается функциями выработки и проверки ЭЦП: 
\verb|C_SignInit|, \verb|C_SignUpdate|, \verb|C_SignFinal|, 
\verb|C_VerifyInit|, \verb|C_VerifyUpdate|, \verb|C_VerifyFinal|.

При выработке подписи описатели механизма и объекта
личного ключа подаются на вход функции \verb|C_SignInit|.
Подписываемые данные целиком или по частям подаются
на вход функции \verb|C_SignUpdate|.
Указатель на выходное значение подписи вместе с размером
подается на вход функции \verb|C_SignFinal|.

При проверке подписи описатели механизма и объекта
открытого ключа подаются на вход функции \verb|C_VerifyInit|.
Подписанные данные целиком или по-частям подаются
на вход функции \verb|C_VerifyUpdate|.
Указатель на значение подписи вместе с размером
подается на вход функции \verb|C_VerifyFinal|.

В механизме должны использоваться ключи уровня стойкости $l=128$ 
и стандартные параметры ЭК этого уровня (см.~\ref{CRYPTO.Params}).
% 
Буфер подписи, подаваемый на вход функций \verb|C_SignFinal| и 
\verb|C_VerifyFinal|, должен состоять из 48 октетов.

\subsection{Механизм CKM\_BIGN\_BASH}

Для выработки ЭЦП в соответствии с алгоритмами~\texttt{bign-with-bash384},
\texttt{bign-with-bash512} (см.~\ref{CRYPTO.Sign}) должен использоваться 
механизм \verb|CKM_BIGN_BASH|. Механизм может дополнительно реализовывать 
проверку ЭЦП.
%
Механизм не имеет параметров.

Идентификатор механизма: \texttt{0x00008003}.

Механизм~\verb|CKM_BIGN_BASH| поддерживается теми же функциями и по тем же 
правилам, что и механизм~\verb|CKM_BIGN_HBELT|.

В механизме должны использоваться ключи уровней стойкости $l=192$ и~$l=256$
и стандартные параметры ЭК этих уровней (см.~\ref{CRYPTO.Params}).
% 
Буфер подписи, подаваемый на вход функций \verb|C_SignFinal| и 
\verb|C_VerifyFinal|, должен состоять из 72 ($l=192$) или 96 ($l=256$) 
октетов. 

\subsection{Механизм CKM\_BIGN\_TSP}

%2.3.12

Для разбора токена ключа в соответствии с алгоритмами~\texttt{bign-keytransport}
(см.~\ref{CRYPTO.Transport}) должен использоваться механизм \verb|CKM_BIGN_TSP|. 
Механизм может дополнительно реализовывать создание токена ключа.
%
Параметр механизма~-- заголовок транспортируемого ключа. 
\doubt{Длина заголовка~--- 16 октетов.}

Идентификатор механизма: \texttt{0x00008004}.

Механизм подерживается функциями создания и разбора токена ключа:
\verb|C_WrapKey| и \verb|C_UnwrapKey|.

При создании токена на вход функции \verb|C_WrapKey| подаются
описатель механизма, описатели объектов открытого ключа
получателя и транспортируемого ключа, указатель на
выходное значение токена ключа вместе с размером.
Размер транспортируемого ключа должен быть не менее 16 октетов.
Объект транспортируемого ключа может иметь произвольный класс и тип.

При разборе токена на вход функции \verb|C_UnwrapKey| подаются
описатель механизма, описатель объекта личного ключа
получателя, указатель на значение токена ключа вместе с размером,
набор атрибутов для создания нового ключа.
Размер токена ключа должен быть не менее 32 октетов.
Объект нового ключа может иметь произвольный класс и тип.

\section{Сценарий работы}

В этом разделе рассматривается типовой сценарий работы,
включающий следующие шаги: выбор токена стороннего
производителя, аутентификация с помощью PIN-кода, выбор
личного ключа и выработка подписи, завершение работы.
Для каждого шага описываются основные действия и
уточняются, где это необходимо, аргументы функций Cryptoki,
используемых при этом.
Сами функции, принимаемые аргументы и примеры
их использования определены в СТБ 34.101.21.

Произволитель токенов должен предоставить библиотеку,
реализующую интерфейс Cryptoki. Перед началом работы прикладная
программа, желающая работать с токенами конкретного
производителя, должна загрузить соответствующую библиотеку
Cryptoki. Библиотека OpenSC реализует Cryptoki и позволяет
взаимодействовать со смарт-картами многих производителей.

\subsection{Начало работы и выбор токена}

% функции общего назначения
В начале работы библиотека Cryptoki должна быть
проинициализирована с помощью функции \verb|C_Initialize|.

Получить информацию о библиотеке, в т.е. версию интерфейса
Cryptoki, идентификатор производителя, описание и версию
библиотеки, можно с помощью функции \verb|C_GetInfo|.
\doubt{Эта функция может быть использована для подтверждения
возможности работы согласно Cryptoki необходимой версии,
а также с токенами конкретного производителя.}

Затем требуется получить список указателей на функции Cryptoki
с помощью \verb|C_GetFunctionList|.

% функции управления слотами и токенами
Следующим этапом требуется выбрать слот -- логическое
устройство чтения токенов (например, считыватель смарт-карт),
а затем токен.
Функция \verb|C_GetSlotList| возвращает список слотов в системе.

Для получения информации о слоте, включая описание слота,
идентификатор производителя, версии прошивки и аппаратной
части слота, используется функция \verb|C_GetSlotInfo|.
\doubt{Эта функция может быть использована для потверждения
выбора требуемого слота.}

Для получения информации о токене, находящемся в выбранном
слоте, используется функция \verb|C_GetTokenInfo|.
Функция возвращает метку токена, идентификатор производителя,
модель и серийный номер токена, версии прошивки и
аппаратной части токена.
\doubt{Эта функция может быть использована для потверждения
выбора требуемого токена.}

Для получения списка механизмов, поддерживаемых токеном,
используется функция \verb|C_GetMechanismList|.
\doubt{Эта функция может быть использована для потверждения
поддержки токеном механизмов, определенных в настоящем
стандарте.}

%TODO: Этот подраздел можно сократить до:
%Библиотека должна поддерживать Cryptoki версии не ниже 2.20.
%Токен должен поддерживать механизмы, описанные в данном стандарте.

\subsection{Аутентификация}

% функции управления сессиями
После поиска и выбора токена требуется открыть сеанс
взаимодействия между прикладной программой и токеном с
помощью функции \verb|C_OpenSession|.

Для аутентификации пользователя перед токеном в рамках
выбранной сессии требуется вызвать функцию \verb|C_Login|.

Успешное выполнение функции \verb|C_Login| разрешает
выполнение команд с критическими объектами (ключами).

\doubt{Токены согласно СТБ 34.101.btok при аутентификации
принимают дополнительный параметр, определяющий количество
выработок подписей без дополнительного подтверждения PIN-кода.}
Функции \verb|C_OpenSession| и \verb|C_Login| не принимают
дополнительные параметры, которые можно использовать для
изменения их поведения.

%TODO:
%Количество выработок подписей можно передавать как первый или
%последний байт PIN-кода, но прикладная программа и библиотека
%должны поддерживать такое поведение, не соответствующее
%интерфейсу Cryptoki.

\subsection{Выбор личного ключа}

% функции управления объектами
Выработать пару ключей можно с помощью функции
\verb|C_GenerateKeyPair|, на вход которой подаются атрибуты
объектов открытого и личного ключей.

Выбор существующих ключей выполняется с помощью функций
поиска объектов. Функция \verb|C_FindObjectsInit| инициализации
поиска объекта позволяет задать критерии поиска на основании
шаблона, в котором указываются атрибуты искомого объекта.
Функция \verb|C_FindObjects| возвращает описатели объектов,
удовлетворяющих шаблону. Функция \verb|C_FindObjectsFinal|
завершает поиск.

При создании шаблона объекта личного ключа для однозначной
идентификации объекта следует указывать атрибут \verb|CKA_ID|.

Функции генерации и поиска возвращают описатели ключевых
объектов, которые могут быть использованы при выработке подписи
и транспорте ключа.

%TODO: Этот подраздел можно сократить до:
%При генерации и выборе личных ключей нужно указывать
%атрибут \verb|CKA_ID|.

%\subsection{Выработка подписи}
%\subsection{Создание запроса на выпуск сертификата}
%\subsection{Транспорт ключа}

\subsection{Завершение работы}

Для завершения работы с критическими объектами токена
используется функция \verb|C_Logout|.

Для завершения сеанса работы с токеном используется функция
\verb|C_CloseSession|.

Для завершения работы и деинициализации библиотеки
используется функция \verb|C_Finalize|.
